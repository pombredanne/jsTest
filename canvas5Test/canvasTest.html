<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <script type="text/javascript" src="jquery-1.9.1.min.js"></script>
    <title></title>
</head>
<body>
    <!--
        默认:300 * 150的矩形

        fillRect: 起点的横纵坐标 宽高
        fillStyle:  画布的颜色
    -->
    <section>
        <header><h1>画矩形 以及增加保存图片dataURl格式</h1></header>
        <canvas id="canvasTestRect" width="400" height="300">赶紧的 更换浏览器去 火狐 chrome啊 赶紧的</canvas>
    </section>
    <script type="text/javascript">
        var canvas=document.getElementById('canvasTestRect');
        /*
         *   [
         *      fill:一般指绘画 画布
         *      stroke:一般指绘画 线条
         *      clearRect:  清楚矩形 就好比一个橡皮擦
         *   ]
         *
         */
        var context = canvas.getContext("2d");
        //实践表明在不设施fillStyle下的默认fillStyle=black
         context.fillRect(0, 0,100, 100);
        //实践表明在不设施strokeStyle下的默认strokeStyle=black
        context.strokeRect(120, 0, 100, 100);

        //设置纯色
        context.fillStyle = "red";              //fillStyle 填充的样式
        context.strokeStyle = "blue";           //strokeStyle 边框样式
        context.fillRect(0, 120, 100, 100);
        context.strokeRect(120, 120, 100, 100);

        //设置透明度实践证明透明度值>0,<1值越低，越透明，值>=1时为纯色，值<=0时为完全透明
        context.fillStyle = "rgba(255,0,0,0.2)";
        context.strokeStyle = "rgba(255,0,0,0.2)";
        context.fillRect(240,0 , 100, 100);
        context.strokeRect(240, 120, 100, 100);
        context.clearRect(50, 50, 240, 120);  //  x:清除矩形起点横坐标  y:清除矩形起点纵坐标  width:清除矩形长度 height:清除矩形高度
        //把图像保存到新的窗口
        var w=window.open(canvas.toDataURL("image/jpeg"),"smallwin","width=400,height=350");
    </script>

    <section>
        <header><h1>绘制路径</h1></header>
        <canvas id="canvasTestPath" width="400" height="300"></canvas>
    </section>
    <script type="text/javascript">
        var canvas = document.getElementById('canvasTestPath');
        var context = canvas.getContext('2d');
        /*
        *   [
        *       beginPath: 开始绘制
        *       close
        *   ]
        */
        var n = 0;
        //左侧1/4圆弧
        context.beginPath();                                 //开始绘制
        context.arc(100, 150, 50, 0, Math.PI/2 , false);     //x:圆心的x坐标 y:圆心的y坐标 r:圆的半径。 straAngle:开始角度  endAngle:结束角度  anticlockwise:是否逆时针（false）为逆时针，(true)为顺时针
        context.fillStyle = 'rgba(255,0,0,0.25)';
        context.fill();                                     // fill 填充
        context.strokeStyle = 'rgba(255,0,0,0.25)'
        context.closePath();                                //结束绘制
        context.stroke();                                   //绘制边框

        //右侧1/4圆弧
        context.beginPath();
        context.arc(300, 150 ,50,0*Math.PI,1.5*Math.PI,false);
        //context.fillStyle = 'rgba(255,0,0,0.25)';
        //context.fill();
        context.strokeStyle = 'rgba(255,0,0,0.25)';
        //context.closePath();  //是否打开 或者闭合
        context.stroke();
    </script>

    <section>
        <header><h1>绘制路径</h1></header>
        <canvas id="canvasTestArc" width="400" height="300"></canvas>
    </section>
    <script type="text/javascript">
        var canvas = document.getElementById('canvasTestArc');
        var context = canvas.getContext('2d');
        context.beginPath();
        context.arc(50, 150, 50, 0, Math.PI * 2, true);
        //不关闭路径路径会一直保留下去，当然也可以利用这个特点做出意想不到的效果
        context.stroke();
        context.closePath();

        context.beginPath();
        context.arc(200,150,60,0,Math.PI*2,true);
        context.fillStyle='blue';
        context.fill();
        context.closePath();
    </script>

    <section>
        <header><h1>绘制线</h1></header>
        <canvas id="canvasTestLine" width="400" height="300"></canvas>
    </section>
    <script type="text/javascript">
        var canvas = document.getElementById('canvasTestLine');
        var context = canvas.getContext("2d");
        context.strokeStyle = "rgb(250,0,0)";
        //无moveTo 就以两次lineTo来进行绘制
        context.lineTo(100, 100);   //x y坐标
        context.lineTo(200, 200);
        //正常的moveto起点到lineTo终点
        context.moveTo(200, 50);
        context.lineTo(100,50);
        context.stroke();
    </script>

    <section>
        <header><h1>绘制曲线</h1></header>
        <canvas id="canvasTestQuxian" width="400" height="300"></canvas>
    </section>
    <script type="text/javascript">
        var canvas = document.getElementById('canvasTestQuxian');
        var context = canvas.getContext("2d");
        context.bezierCurveTo(50, 50,150, 50, 150, 150);    // cp1x:第一个控制点x坐标  cp1y:第一个控制点y坐标  cp2x:第二个控制点x坐标    cp2y:第二个控制点y坐标    x:终点x坐标 y:终点y坐标
        context.stroke();
        //第二段
        context.quadraticCurveTo(150, 250, 250, 250);       //   qcpx:二次样条曲线控制点x坐标  qcpy:二次样条曲线控制点y坐标  qx:二次样条曲线终点x坐标  qy:二次样条曲线终点y坐标
        context.stroke();
    </script>

    <section>
        <header><h1>绘制渐变线条</h1></header>
        <canvas id="canvasTestJian" width="400" height="300"></canvas>
    </section>
    <script type="text/javascript">
        var canvas = document.getElementById('canvasTestJian');
        var context = canvas.getContext('2d');
        var g1 = context.createLinearGradient(0, 0, 0, 300);    //xstart:渐变开始点x坐标 ystart:渐变开始点y坐标 xEnd:渐变结束点x坐标  yEnd:渐变结束点y坐标

        //绘制渐变颜色 offset:设定的颜色离渐变结束点的偏移量(0~1)  color:绘制时要使用的颜色
        g1.addColorStop(0, 'rgb(255,0,0)'); //红
        g1.addColorStop(0.5, 'rgb(0,255,0)');//绿
        g1.addColorStop(1, 'rgb(0,0,255)'); //蓝

        //可以把lg对象理解成GDI中线性brush
        context.fillStyle = g1;
        //再用这个brush来画正方形
        context.fillRect(0, 0, 400, 300);
    </script>

    <section>
        <header>
            <h1>绘制变形的矩形 弯曲啊 什麽的</h1>
        </header>
        <canvas id="canvasTestRecBianxing" height="300" width="400"></canvas>
    </section>
    <script type="text/javascript">
        var canvas = document.getElementById('canvasTestRecBianxing');
        var context = canvas.getContext("2d");
        //定义颜色
        var colors = ["red", "orange", "yellow", "green", "blue", "navy", "perple"];
        //定义线宽
        context.lineWidth = 10;
        //这里定义总体变换的位置
        context.transform(1,0,0,1,100,0);       //a:水平旋转绘图  b:水平倾斜绘图  c:垂直倾斜绘图  d:垂直缩放绘图  e:水平移动绘图  f:垂直移动绘图

        //循环绘制圆弧
        for (var i = 0; i < colors.length; i++) {
            //定义每次向下移动10个像素的变换矩阵
            context.transform(1, 0, 0, 1, 0, 10);
            //设定颜色
            context.strokeStyle = colors[i];
            context.beginPath();
            context.arc(50, 100, 100, 0, Math.PI, true);
            context.stroke();
        }
    </script>

    <section>
        <header><h1>给图像绘制阴影demo shadowOffsetX(阴影的横向位移量) shadowOffsetY(盈盈的纵向位移量) shadowColor（阴影的颜色） shadowBlur（阴影的模糊范围）</h1></header>
        <canvas height="300" width="400" id="canvasTestYinying"></canvas>
    </section>
    <script type="text/javascript">
        function create5Star(context) {
            var n = 0;
            var dx = 100;
            var dy = 0;

            var s = 50;
            //创建路径
            context.beginPath();
            context.fillStyle = 'rgba(255,0,0,0.5)';
            var x = Math.sin(0);
            var y = Math.cos(0);
            var dig = Math.PI / 5 * 4;
            for (var i = 0; i < 5; i++) {
                x = Math.sin(i * dig);
                y = Math.cos(i * dig);
                context.lineTo(dx + x * s, dy + y * s);
            }
            context.closePath();

        }
        var canvas = document.getElementById('canvasTestYinying');
        var context = canvas.getContext("2d");
        context.fillStyle = "#EEEEFF";
        context.fillRect(0, 0, 400, 300);

        context.shadowOffsetX = 10;
        context.shadowOffsetY = 10;
        context.shadowColor = 'rgba(100,100,100,0.5)';
        context.shadowBlur =5;  //阴影的模糊级数
        //图形绘制
        context.translate(0, 50);   //再次绘制图形的 坐标
        for (var i = 0; i < 3; i++) {
            context.translate(50, 50);
            create5Star(context);
            context.fill();
        }
    </script>
    
    <section>
        <header><h1>绘制文字fillText strokeText</h1></header>
        <canvas height="300" width="400" id="canvasTestFont"></canvas>
    </section>
    <script>
        var canvas = document.getElementById('canvasTestFont');
        var context = canvas.getContext("2d");
        context.fillStyle = "#EEEEFF";
        context.fillRect(0,0,400,300);
        context.fillStyle = "#00f";
        context.font = "italic 30px sans-serif";
        context.textBaseline = 'top';
        //填充字符串
        var txt="fill示例文字"
        context.fillText(txt, 0, 0);
        var length=context.measureText(txt);
        context.fillText("长" + length.width + "px", 0, 50);
        context.font = "bolid 30px sans-serif";
        txt = "stroke示例文字";
        length = context.measureText(txt);
        context.strokeText(txt,0,100);
        context.fillText("长" + length.width + "px", 0, 150);
    </script>
    
    <section>
        <header><h1>图像裁剪clip</h1></header>
        <canvas id='canvasTestClip' height="300" width="400"></canvas>
    </section>
    <script>
        function drawImg(context, image) {
            //圆形裁剪区
            //createCircleClip(context)
            //星形裁剪区
            create5StarClip(context);
            context.drawImage(image,0,0);
        }
        function create5StarClip(context) {
            var n = 0;
            var dx = 200;
            var dy = 135;
            var s = 150;
            context.beginPath();
            var x = Math.sin(0);
            var y = Math.cos(0);
            var dig = Math.PI / 5 * 4;
            for (var i = 0; i < 5; i++) {
                var x = Math.sin(i * dig);
                var y = Math.cos(i * dig);
                context.lineTo(dx + x * s, dy + y * s);
            }
            context.closePath();
            context.clip();
        }
        var canvas = document.getElementById('canvasTestClip');
        var context = canvas.getContext("2d");
        context.fillStyle = "black";
        context.fillRect(0, 0, 400, 300);
        image = new Image();
        image.src = "HTML5canvasAPI/Image/html5.jpg";
        image.onload = function () {
            drawImg(context,image);
        }
    </script>
    
    
</body>
</html>